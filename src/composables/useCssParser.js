import { parse, walk, generate } from 'css-tree'

// Pre-compiled regexes for performance (Static)
const states = ['hover', 'active', 'focus', 'visited', 'focus-within', 'focus-visible', 'target']
const stateRegexes = states.reduce((acc, state) => {
  acc[state] = new RegExp(':' + state + '(\\b|:)', '')
  return acc
}, {})

const pseudoElementRegex =
  /::?(after|before|first-letter|first-line|selection|backdrop|marker|placeholder|file-selector-button)/g

export function useCssParser() {
  function extractCssAst(targetDoc = document) {
    console.time('extractCssAst')
    const targetWin = targetDoc.defaultView || window
    const masterAst = {
      type: 'StyleSheet',
      loc: null,
      children: [],
    }

    const currentDomain = targetWin.location.hostname

    let nodeCounter = 0
    const nextId = () => `node-${++nodeCounter}`

    // Detect Tailwind Configuration from script tags to propagate data-location
    const tailwindScript = targetDoc.querySelector('script[src*="tailwindcss.com"]')
    const tailwindLocation = tailwindScript?.getAttribute('data-location')

    Array.from(targetDoc.styleSheets).forEach((sheet) => {
      try {
        const owner = sheet.ownerNode
        if (
          owner &&
          (owner.id === 'vite-plugin-vue-devtools' ||
            owner.id === 'live-inspector-styles' ||
            owner.id === 'editor-ui-styles')
        ) {
          if (owner.id === 'live-inspector-styles') owner.dataset.captured = 'true'
          return
        }

        // 1. Determine Origin
        let origin = 'internal'
        let sourceName = 'style'

        // Check if this stylesheet was generated by Tailwind
        const isTailwind = owner && (
          owner.id?.includes('tailwind') || 
          (owner.tagName === 'STYLE' && owner.textContent.includes('--tw-'))
        )

        if (owner && owner.getAttribute('data-location')) {
          origin = owner.getAttribute('data-location').toLowerCase()
          if (origin === 'internal' && owner.id) sourceName = owner.id
        } else if (isTailwind) {
          origin = tailwindLocation || 'external'
          sourceName = 'tailwindcss'
        } else if (sheet.href) {
          try {
            const url = new URL(sheet.href)
            const isLocal =
              url.hostname === currentDomain ||
              url.hostname === 'localhost' ||
              url.hostname === '127.0.0.1'

            origin = isLocal ? 'internal' : 'external'
            sourceName = url.pathname.split('/').pop() || sheet.href
          } catch (e) {
            origin = 'external'
            sourceName = sheet.href || 'external link'
          }
        } else if (owner && owner.tagName === 'STYLE') {
          const viteId = owner.getAttribute('data-vite-dev-id')
          if (viteId) {
            origin = 'internal'
            sourceName = viteId.split('/').pop().split('?')[0]
          } else {
            origin = 'on_page'
          }
        }

        // 2. Get CSS Text
        let cssText = ''
        
        // Try getting text from owner first (good for internal/injected styles)
        if (owner && owner.tagName === 'STYLE' && owner.textContent.trim().length > 0) {
          cssText = owner.textContent
        } else {
          // Try reading rules (necessary for <link> tags and some injected styles)
          try {
            const rules = sheet.cssRules || sheet.rules
            if (rules) {
              cssText = Array.from(rules)
                .map((r) => r.cssText)
                .join('\n')
            }
          } catch (e) {
            console.warn(`[useCssParser] Cannot read rules from ${sourceName} (${origin}). Likely CORS restriction.`, e)
            return
          }
        }

        if (!cssText.trim()) {
          return
        }

        console.log(`[useCssParser] Processing ${sourceName} [${origin}] (${cssText.length} bytes)`)

        // 3. Parse and Tag
        const sheetAst = parse(cssText, {
          positions: true,
          parseValue: true,
          parseCustomProperty: true,
          parseAtrulePrelude: true,
        })

        // Flag all top-level rules with the origin
        walk(sheetAst, {
          visit: 'Rule',
          enter(node) {
            node.origin = origin
            node.sourceName = sourceName
            node._nodeId = nextId()
          },
        })
        walk(sheetAst, {
          visit: 'Atrule',
          enter(node) {
            node.origin = origin
            node.sourceName = sourceName
            node._nodeId = nextId()
          },
        })

        // Flag as captured so we can safely disable the original
        if (owner) owner.dataset.captured = 'true'

        // 4. Merge into Master
        const children = sheetAst.children.toArray ? sheetAst.children.toArray() : sheetAst.children
        children.forEach((child) => masterAst.children.push(child))
      } catch (e) {
        console.warn('Skip sheet due to error:', e)
      }
    })

    console.log(`AST Master extracted with ${masterAst.children.length} rules.`)
    console.timeEnd('extractCssAst')

    // Convert master children back to css-tree List if it was one, or keep as array
    // css-tree generate actually handles arrays too in some versions
    return masterAst
  }

  function isMediaActive(condition) {
    if (!condition) return true
    return window.matchMedia(condition).matches
  }

  function isContainerActive(condition, viewport) {
    if (!condition) return true
    if (condition.includes('min-width')) {
      const match = condition.match(/min-width:\s*(\d+)/)
      return match ? viewport.width >= Number(match[1]) : true
    }
    return true
  }

  function getMatchedRules(targetEl, ast, viewport, forceStatus = {}) {
    if (!targetEl || !ast) return []
    const groups = []
    let currentEl = targetEl

    // Walk up the DOM tree
    while (currentEl && currentEl.nodeType === 1) {
      const isTarget = currentEl === targetEl
      const matched = []
      const targetWin = currentEl.ownerDocument?.defaultView || window

      // 1. Inline Styles (Parse the attribute string to avoid shorthand expansion and 'initial' spam)
      const inlineDecls = []
      const styleAttr = currentEl.getAttribute('style') || ''
      
      if (styleAttr.trim()) {
        try {
          const inlineAst = parse(styleAttr, { context: 'declarationList' })
          let declIndex = 0
          walk(inlineAst, {
            visit: 'Declaration',
            enter(node) {
              const propName = node.property.toLowerCase()
              const isDisabled = propName.startsWith('--disabled-')
              const rawValue = generate(node.value)
              
              inlineDecls.push({
                id: `inline-decl-${declIndex++}`,
                prop: isDisabled ? propName.replace('--disabled-', '') : propName,
                value: rawValue,
                important: !!node.important,
                disabled: isDisabled,
              })
            }
          })
        } catch (e) {
          console.warn('Failed to parse inline style attribute, falling back to legacy iteration', e)
          // Fallback logic for safety
          const styleNames = Array.from(currentEl.style)
          styleNames.forEach((prop, i) => {
            const isDisabled = prop.startsWith('--disabled-')
            const value = currentEl.style.getPropertyValue(prop)
            inlineDecls.push({
              id: `inline-decl-${i}`,
              prop: isDisabled ? prop.replace('--disabled-', '') : prop,
              value: value,
              important: currentEl.style.getPropertyPriority(prop) === 'important',
              disabled: isDisabled,
            })
          })
        }
      }

      if (isTarget || inlineDecls.length > 0) {
        matched.push({
          uid: isTarget ? 'inline-target' : `inline-parent-${groups.length}`,
          selector: 'element.style',
          declarations: inlineDecls,
          specificity: [1, 0, 0, 0],
          context: [],
          active: true,
          loc: 'inline',
        })
      }

      // 2. Traversal with context stack
      const stack = []
      walk(ast, {
        enter(node) {
          if (node.type === 'Atrule' || node.type === 'Rule') {
            stack.push(node)
          }

          if (node.type === 'Rule') {
            const selector = generate(node.prelude)
            if (!selector) return

            // Filter pseudo-states based on forceStatus
            let hasDynamicPseudo = false
            let anyStateSelected = false

            for (const state of states) {
              if (stateRegexes[state].test(selector)) {
                hasDynamicPseudo = true
                if (isTarget && forceStatus[state]) {
                  anyStateSelected = true
                  break
                }
              }
            }

            if (hasDynamicPseudo && !anyStateSelected) return

            try {
              // Clean selector for matching
              let cleanedSelector = selector
              states.forEach((state) => {
                const globalRegex = new RegExp(':' + state + '(\\b|:)', 'g')
                cleanedSelector = cleanedSelector.replace(globalRegex, '$1')
              })
              cleanedSelector = cleanedSelector.replace(pseudoElementRegex, '')

              if (!currentEl.matches(cleanedSelector)) {
                return
              }
            } catch (e) {
              return
            }

            const declarations = []
            const inheritedProperties = [
              'color', 'font', 'font-family', 'font-size', 'font-weight', 'font-style', 'font-variant',
              'line-height', 'letter-spacing', 'text-align', 'text-indent', 'text-transform', 'white-space',
              'word-spacing', 'text-shadow', 'list-style', 'list-style-type', 'list-style-position',
              'list-style-image', 'visibility', 'cursor', 'quotes', 'border-collapse', 'border-spacing',
              'caption-side', 'pointer-events', 'speak', 'direction', 'writing-mode'
            ]

            walk(node.block, {
              visit: 'Declaration',
              enter(decl) {
                const propName = decl.property.toLowerCase()
                const isDisabled = propName.startsWith('--disabled-')
                const cleanProp = isDisabled ? propName.replace('--disabled-', '') : propName

                // Filter for inheritance if not on the target element
                if (!isTarget) {
                  const isInherited = inheritedProperties.includes(cleanProp)
                  if (!isInherited) return
                }

                const rawValue = generate(decl.value)
                const declId = `decl-${decl.property}-${rawValue}-${isDisabled ? 'd' : 'e'}`

                declarations.push({
                  id: declId,
                  prop: isDisabled ? decl.property.replace('--disabled-', '') : decl.property,
                  value: rawValue,
                  important: !!decl.important,
                  loc: decl.loc ? `${decl.loc.start.line}` : null,
                  astNode: decl,
                  disabled: isDisabled,
                })
              },
            })

            if (declarations.length === 0) return

            const context = []
            let active = true

            stack.forEach((p) => {
              if (p.type === 'Atrule') {
                const name = p.name.toLowerCase()
                const cond = p.prelude ? generate(p.prelude) : ''

                context.push({
                  type: 'Atrule',
                  name: name,
                  prelude: cond,
                  wrapper: name === 'layer' ? `(layer ${cond})` : `@${name} ${cond}`,
                  astNode: p,
                })

                if (name === 'media') active = active && targetWin.matchMedia(cond).matches
                if (name === 'container') active = active && isContainerActive(cond, viewport)
              }
            })

            matched.push({
              uid: `rule-${selector}-${node.loc?.start.line || 'nl'}-${Math.random()
                .toString(36)
                .substr(2, 5)}`,
              selector,
              declarations,
              specificity: getSpecificity(selector),
              context,
              active,
              origin: node.origin || 'internal',
              sourceName: node.sourceName || 'style',
              loc: node.loc ? node.loc.start.line : '?',
              astNode: node,
            })
          }
        },
        leave(node) {
          if (node.type === 'Atrule' || node.type === 'Rule') {
            stack.pop()
          }
        },
      })

      if (matched.length > 0) {
        groups.push({
          isTarget,
          tagName: currentEl.tagName.toLowerCase(),
          id: currentEl.id,
          className: currentEl.className,
          rules: matched.sort((a, b) => {
            // Sort by specificity descending
            for (let i = 0; i < 4; i++) {
              if (a.specificity[i] !== b.specificity[i]) {
                return b.specificity[i] - a.specificity[i]
              }
            }
            return 0
          }),
        })
      }

      // Stop at body unless the target itself is body/html
      if (currentEl.tagName === 'BODY' || currentEl.tagName === 'HTML') break
      currentEl = currentEl.parentElement
    }

    return groups
  }

  function getSpecificity(sel) {
    if (!sel) return [0, 0, 0, 0]
    const ids = (sel.match(/#/g) || []).length
    const classes = (sel.match(/\.|\[|:/g) || []).length
    const tags = (sel.match(/(^|\s)[a-z]+/gi) || []).length
    return [0, ids, classes, tags]
  }

  function syncAstToStyles(ast, targetDoc = document) {
    if (!ast) return
    console.time('syncAstToStyles')
    try {
      const css = generate(ast)
      console.log('--- syncAstToStyles --- | Length:', css.length)

      let styleEl = targetDoc.getElementById('live-inspector-styles')
      if (!styleEl) {
        styleEl = targetDoc.createElement('style')
        styleEl.id = 'live-inspector-styles'
        targetDoc.head.appendChild(styleEl)
      }
      styleEl.textContent = css
      console.log('Live styles updated in DOM')
    } catch (e) {
      console.error('Failed to sync AST to styles:', e)
    }
    console.timeEnd('syncAstToStyles')
  }

  function isColor(value) {
    if (!value) return false
    return (
      value.startsWith('#') ||
      value.startsWith('rgb') ||
      value.startsWith('hsl') ||
      [
        'red',
        'blue',
        'green',
        'yellow',
        'black',
        'white',
        'gray',
        'purple',
        'orange',
        'pink',
        'teal',
        'indigo',
        'cyan',
        'magenta',
      ].includes(value.toLowerCase())
    )
  }

  function setSheetsDisabled(disabled, targetDoc = document) {
    Array.from(targetDoc.styleSheets).forEach((sheet) => {
      try {
        const owner = sheet.ownerNode
        if (
          owner &&
          (owner.id === 'vite-plugin-vue-devtools' ||
            owner.id === 'live-inspector-styles' ||
            owner.dataset.captured !== 'true')
        )
          return

        sheet.disabled = disabled
      } catch (e) {
        // Safe skip
      }
    })
  }

  return {
    extractCssAst,
    getMatchedRules,
    getSpecificity,
    syncAstToStyles,
    isColor,
    setSheetsDisabled,
    parse,
    walk,
    generate,
    createNode(css, context) {
      try {
        // css-tree requires lowercase context names
        const normalizedContext = context.toLowerCase()
        const ast = parse(css, { context: normalizedContext })
        return ast
      } catch (e) {
        console.error('Failed to create node from CSS:', css, 'context:', context, e)
        return null
      }
    },
  }
}
