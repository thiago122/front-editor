import { parse, walk, generate } from 'css-tree'
import { generateId } from '../utils/ids.js'

// Pre-compiled regexes for performance (Static)
const states = ['hover', 'active', 'focus', 'visited', 'focus-within', 'focus-visible', 'target']
const stateRegexes = states.reduce((acc, state) => {
  acc[state] = new RegExp(':' + state + '(\\b|:)', '')
  return acc
}, {})

const pseudoElementRegex =
  /::?(after|before|first-letter|first-line|selection|backdrop|marker|placeholder|file-selector-button)/g

export function useCssParser() {
  function extractCssAst(targetDoc = document) {
    console.time('extractCssAst')
    const targetWin = targetDoc.defaultView || window
    const masterAst = {
      type: 'StyleSheet',
      loc: null,
      children: [],
    }

    const currentDomain = targetWin.location.hostname

    let nodeCounter = 0
    const nextId = () => `node-${++nodeCounter}`

    // Detect Tailwind Configuration from script tags to propagate data-location
    const tailwindScript = targetDoc.querySelector('script[src*="tailwindcss.com"]')
    const tailwindLocation = tailwindScript?.getAttribute('data-location')

    Array.from(targetDoc.styleSheets).forEach((sheet) => {
      try {
        const owner = sheet.ownerNode
        if (
          owner &&
          (owner.id === 'vite-plugin-vue-devtools' ||
            owner.id === 'live-inspector-styles' ||
            owner.id === 'editor-ui-styles')
        ) {
          if (owner.id === 'live-inspector-styles') owner.dataset.captured = 'true'
          return
        }

        // 1. Determine Origin
        let origin = 'internal'
        let sourceName = 'style'

        // Check if this stylesheet was generated by Tailwind
        const isTailwind = owner && (
          owner.id?.includes('tailwind') || 
          (owner.tagName === 'STYLE' && owner.textContent.includes('--tw-'))
        )

        if (owner && owner.getAttribute('data-location')) {
          origin = owner.getAttribute('data-location').toLowerCase()
          if (origin === 'internal' && owner.id) sourceName = owner.id
        } else if (isTailwind) {
          origin = tailwindLocation || 'external'
          sourceName = 'tailwindcss'
        } else if (sheet.href) {
          try {
            const url = new URL(sheet.href)
            const isLocal =
              url.hostname === currentDomain ||
              url.hostname === 'localhost' ||
              url.hostname === '127.0.0.1'

            origin = isLocal ? 'internal' : 'external'
            sourceName = url.pathname.split('/').pop() || sheet.href
          } catch (e) {
            origin = 'external'
            sourceName = sheet.href || 'external link'
          }
        } else if (owner && owner.tagName === 'STYLE') {
          const viteId = owner.getAttribute('data-vite-dev-id')
          if (viteId) {
            origin = 'internal'
            sourceName = viteId.split('/').pop().split('?')[0]
          } else {
            origin = 'on_page'
          }
        }

        // 2. Get CSS Text
        let cssText = ''
        
        // Try getting text from owner first (good for internal/injected styles)
        if (owner && owner.tagName === 'STYLE' && owner.textContent.trim().length > 0) {
          cssText = owner.textContent
        } else {
          // Try reading rules (necessary for <link> tags and some injected styles)
          try {
            // Browsers throw SecurityError when accessing cssRules of cross-origin sheets without CORS
            const rules = sheet.cssRules || sheet.rules
            if (rules) {
              cssText = Array.from(rules)
                .map((r) => r.cssText)
                .join('\n')
            }
          } catch (e) {
            // Only log once per sheet to avoid console spam during refreshes
            if (!sheet._corsErrorLogged) {
              console.warn(`[useCssParser] Style "${sourceName}" is CORS-protected. External rules cannot be inspected without 'crossorigin' attribute on the link tag.`, e.message)
              sheet._corsErrorLogged = true
            }
            return
          }
        }

        if (!cssText.trim()) {
          return
        }

        console.log(`[useCssParser] Processing ${sourceName} [${origin}] (${cssText.length} bytes)`)

        // 3. Parse and Tag
        const sheetAst = parse(cssText, {
          positions: true,
          parseValue: true,
          parseCustomProperty: true,
          parseAtrulePrelude: true,
        })

        // Flag all top-level rules with the origin
        walk(sheetAst, {
          visit: 'Rule',
          enter(node) {
            node.origin = origin
            node.sourceName = sourceName
            node._nodeId = nextId()
          },
        })
        walk(sheetAst, {
          visit: 'Atrule',
          enter(node) {
            node.origin = origin
            node.sourceName = sourceName
            node._nodeId = nextId()
          },
        })

        // Flag as captured so we can safely disable the original
        if (owner) owner.dataset.captured = 'true'

        // 4. Merge into Master
        const children = sheetAst.children.toArray ? sheetAst.children.toArray() : sheetAst.children
        children.forEach((child) => masterAst.children.push(child))
      } catch (e) {
        console.warn('Skip sheet due to error:', e)
      }
    })

    console.log(`AST Master extracted with ${masterAst.children.length} rules.`)
    console.timeEnd('extractCssAst')

    // 5. Transform to Logic Tree
    return transformToLogicTree(masterAst)
  }

  function transformToLogicTree(masterAst) {
    const rootNodes = []
    const locations = ['inline', 'on_page', 'internal', 'external']

    // 1. Create Location Roots
    const locationMap = {}
    locations.forEach((loc) => {
      const node = {
        id: generateId(),
        type: 'root',
        label: loc.toUpperCase().replace('_', ' '),
        metadata: { origin: loc },
        children: [],
      }
      locationMap[loc] = node
      rootNodes.push(node)
    })

    // 2. Group by Source within Location
    masterAst.children.forEach((cssNode) => {
      const origin = cssNode.origin || 'internal'
      const sourceName = cssNode.sourceName || (origin === 'on_page' ? 'on-page' : 'style')

      const locationNode = locationMap[origin]
      let fileNode = locationNode.children.find((c) => c.type === 'file' && c.label === sourceName)

      if (!fileNode) {
        fileNode = {
          id: generateId(),
          type: 'file',
          label: sourceName,
          metadata: { origin, sourceName },
          children: [],
        }
        locationNode.children.push(fileNode)
      }

      // 3. Recursive Transform
      const logicNode = mapCssNodeToLogicNode(cssNode)
      if (logicNode) {
        fileNode.children.push(logicNode)
      }
    })

    // Filter out empty location roots
    return rootNodes.filter((rn) => rn.children.length > 0)
  }

  function mapCssNodeToLogicNode(node) {
    if (!node) return null

    const logicNode = {
      id: generateId(),
      type: '',
      label: '',
      value: '',
      metadata: {
        origin: node.origin,
        line: node.loc?.start?.line,
        astNode: node,
      },
      children: [],
    }

    if (node.type === 'Rule') {
      logicNode.type = 'selector'
      logicNode.label = generate(node.prelude)
      logicNode.metadata.specificity = getSpecificity(logicNode.label)

      // Add Declarations and Nested Rules
      if (node.block && node.block.children) {
        const children = node.block.children.toArray ? node.block.children.toArray() : node.block.children
        children.forEach((child) => {
          const childLogic = mapCssNodeToLogicNode(child)
          if (childLogic) logicNode.children.push(childLogic)
        })
      }
    } else if (node.type === 'Atrule') {
      logicNode.type = 'at-rule'
      const prelude = node.prelude ? generate(node.prelude) : ''
      logicNode.label = `@${node.name} ${prelude}`.trim()

      if (node.block && node.block.children) {
        const children = node.block.children.toArray ? node.block.children.toArray() : node.block.children
        children.forEach((child) => {
          const childLogic = mapCssNodeToLogicNode(child)
          if (childLogic) logicNode.children.push(childLogic)
        })
      }
    } else if (node.type === 'Declaration') {
      logicNode.type = 'declaration'
      logicNode.label = node.property
      logicNode.value = generate(node.value)
    } else {
      return null // Ignore other types for now
    }

    return logicNode
  }

  function isMediaActive(condition) {
    if (!condition) return true
    return window.matchMedia(condition).matches
  }

  function isContainerActive(condition, viewport) {
    if (!condition) return true
    if (condition.includes('min-width')) {
      const match = condition.match(/min-width:\s*(\d+)/)
      return match ? viewport.width >= Number(match[1]) : true
    }
    return true
  }

  function getMatchedRules(targetEl, ast, viewport, forceStatus = {}) {
    if (!targetEl || !ast) return []
    const groups = []
    let currentEl = targetEl

    // Walk up the DOM tree
    while (currentEl && currentEl.nodeType === 1) {
      const isTarget = currentEl === targetEl
      const matched = []
      const targetWin = currentEl.ownerDocument?.defaultView || window

      // 1. Inline Styles (Parse the attribute string to avoid shorthand expansion and 'initial' spam)
      const inlineDecls = []
      const styleAttr = currentEl.getAttribute('style') || ''
      
      if (styleAttr.trim()) {
        try {
          const inlineAst = parse(styleAttr, { context: 'declarationList' })
          let declIndex = 0
          walk(inlineAst, {
            visit: 'Declaration',
            enter(node) {
              const propName = node.property.toLowerCase()
              const isDisabled = propName.startsWith('--disabled-')
              const rawValue = generate(node.value)
              
              inlineDecls.push({
                id: `inline-decl-${declIndex++}`,
                prop: isDisabled ? propName.replace('--disabled-', '') : propName,
                value: rawValue,
                important: !!node.important,
                disabled: isDisabled,
              })
            }
          })
        } catch (e) {
          console.warn('Failed to parse inline style attribute, falling back to legacy iteration', e)
          // Fallback logic for safety
          const styleNames = Array.from(currentEl.style)
          styleNames.forEach((prop, i) => {
            const isDisabled = prop.startsWith('--disabled-')
            const value = currentEl.style.getPropertyValue(prop)
            inlineDecls.push({
              id: `inline-decl-${i}`,
              prop: isDisabled ? prop.replace('--disabled-', '') : prop,
              value: value,
              important: currentEl.style.getPropertyPriority(prop) === 'important',
              disabled: isDisabled,
            })
          })
        }
      }

      if (isTarget || inlineDecls.length > 0) {
        matched.push({
          uid: isTarget ? 'inline-target' : `inline-parent-${groups.length}`,
          selector: 'element.style',
          declarations: inlineDecls,
          specificity: [1, 0, 0, 0],
          context: [],
          active: true,
          loc: 'inline',
        })
      }

      // 2. Logic Tree Traversal with context stack
      const stack = []
      
      const traverseLogicNodes = (nodes) => {
        nodes.forEach(logicNode => {
          if (logicNode.type === 'at-rule') {
            const name = logicNode.label.split(' ')[0].replace('@', '').toLowerCase()
            const cond = logicNode.label.substring(logicNode.label.indexOf(' ') + 1)
            
            const contextItem = {
              type: 'Atrule',
              name: name,
              prelude: cond,
              wrapper: logicNode.label,
              astNode: logicNode.metadata?.astNode,
              logicNodeId: logicNode.id
            }
            
            stack.push(contextItem)
            if (logicNode.children) traverseLogicNodes(logicNode.children)
            stack.pop()
          } else if (logicNode.type === 'selector') {
            const selector = logicNode.label
            if (!selector) return

            // Filter pseudo-states based on forceStatus
            let hasDynamicPseudo = false
            let anyStateSelected = false

            for (const state of states) {
              if (stateRegexes[state].test(selector)) {
                hasDynamicPseudo = true
                if (isTarget && forceStatus[state]) {
                  anyStateSelected = true
                  break
                }
              }
            }

            if (hasDynamicPseudo && !anyStateSelected) return

            try {
              // Clean selector for matching
              let cleanedSelector = selector
              states.forEach((state) => {
                const globalRegex = new RegExp(':' + state + '(\\b|:)', 'g')
                cleanedSelector = cleanedSelector.replace(globalRegex, '$1')
              })
              cleanedSelector = cleanedSelector.replace(pseudoElementRegex, '')

              if (!currentEl.matches(cleanedSelector)) {
                return
              }
            } catch (e) {
              return
            }

            const declarations = []
            const inheritedProperties = [
              'color', 'font', 'font-family', 'font-size', 'font-weight', 'font-style', 'font-variant',
              'line-height', 'letter-spacing', 'text-align', 'text-indent', 'text-transform', 'white-space',
              'word-spacing', 'text-shadow', 'list-style', 'list-style-type', 'list-style-position',
              'list-style-image', 'visibility', 'cursor', 'quotes', 'border-collapse', 'border-spacing',
              'caption-side', 'pointer-events', 'speak', 'direction', 'writing-mode'
            ]

            if (logicNode.children) {
              logicNode.children.forEach(d => {
                if (d.type === 'declaration') {
                  const propName = d.label.toLowerCase()
                  const isDisabled = propName.startsWith('--disabled-')
                  const cleanProp = isDisabled ? propName.replace('--disabled-', '') : propName

                  if (!isTarget && !inheritedProperties.includes(cleanProp)) return

                  declarations.push({
                    id: d.id,
                    prop: cleanProp,
                    value: d.value,
                    important: d.metadata?.astNode?.important || false,
                    loc: logicNode.metadata?.line || '?',
                    astNode: d.metadata?.astNode,
                    disabled: isDisabled,
                  })
                }
              })
            }

            if (declarations.length === 0) return

            // Determine if rule is active (matching media/container)
            let active = true
            stack.forEach(p => {
              if (p.name === 'media') active = active && targetWin.matchMedia(p.prelude).matches
              if (p.name === 'container') active = active && isContainerActive(p.prelude, viewport)
            })

            matched.push({
              uid: logicNode.id,
              selector: selector,
              declarations: declarations,
              specificity: logicNode.metadata?.specificity || [0, 0, 0, 0],
              context: [...stack],
              active: active,
              origin: logicNode.metadata?.origin,
              sourceName: logicNode.metadata?.sourceName,
              loc: logicNode.metadata?.line || '?',
              astNode: logicNode.metadata?.astNode,
            })
          } else if (logicNode.children) {
            traverseLogicNodes(logicNode.children)
          }
        })
      }

      traverseLogicNodes(ast) // Here 'ast' is the logicTree array

      if (matched.length > 0) {
        groups.push({
          isTarget,
          tagName: currentEl.tagName.toLowerCase(),
          id: currentEl.id,
          className: currentEl.className,
          rules: matched.sort((a, b) => {
            // Sort by specificity descending
            for (let i = 0; i < 4; i++) {
              if (a.specificity[i] !== b.specificity[i]) {
                return b.specificity[i] - a.specificity[i]
              }
            }
            return 0
          }),
        })
      }

      // Stop at body unless the target itself is body/html
      if (currentEl.tagName === 'BODY' || currentEl.tagName === 'HTML') break
      currentEl = currentEl.parentElement
    }

    return groups
  }

  function getSpecificity(sel) {
    if (!sel) return [0, 0, 0, 0]
    const ids = (sel.match(/#/g) || []).length
    const classes = (sel.match(/\.|\[|:/g) || []).length
    const tags = (sel.match(/(^|\s)[a-z]+/gi) || []).length
    return [0, ids, classes, tags]
  }

  function syncAstToStyles(logicTree, targetDoc = document) {
    if (!logicTree) return
    console.time('syncAstToStyles')
    try {
      const children = []

      const syncLogicNodeToAst = (logicNode) => {
        const astNode = logicNode.metadata?.astNode
        if (!astNode) return null

        // For containers (at-rules or rules), sync their children back to the AST block
        if ((logicNode.type === 'at-rule' || logicNode.type === 'selector') && logicNode.children) {
          const block = astNode.block
          if (block && block.children) {
            const childAstNodes = logicNode.children
              .map(child => syncLogicNodeToAst(child))
              .filter(Boolean)
            
            if (block.children.fromArray) {
              block.children.fromArray(childAstNodes)
            } else {
              block.children = childAstNodes
            }
          }
        }
        return astNode
      }

      const collectTopRules = (nodes) => {
        nodes.forEach(n => {
          if (n.type === 'file') {
             n.children.forEach(logicChild => {
                const synced = syncLogicNodeToAst(logicChild)
                if (synced) children.push(synced)
             })
          } else if (n.children) {
            collectTopRules(n.children)
          }
        })
      }
      collectTopRules(toRaw(logicTree))

      const masterAst = {
        type: 'StyleSheet',
        children: children
      }

      const css = generate(masterAst)
      console.log('--- syncAstToStyles --- | Length:', css.length)

      let styleEl = targetDoc.getElementById('live-inspector-styles')
      if (!styleEl) {
        styleEl = targetDoc.createElement('style')
        styleEl.id = 'live-inspector-styles'
        targetDoc.head.appendChild(styleEl)
      }
      styleEl.textContent = css
      console.log('Live styles updated in DOM')
    } catch (e) {
      console.error('Failed to sync AST to styles:', e)
    }
    console.timeEnd('syncAstToStyles')
  }

  function isColor(value) {
    if (!value) return false
    return (
      value.startsWith('#') ||
      value.startsWith('rgb') ||
      value.startsWith('hsl') ||
      [
        'red',
        'blue',
        'green',
        'yellow',
        'black',
        'white',
        'gray',
        'purple',
        'orange',
        'pink',
        'teal',
        'indigo',
        'cyan',
        'magenta',
      ].includes(value.toLowerCase())
    )
  }

  function setSheetsDisabled(disabled, targetDoc = document) {
    Array.from(targetDoc.styleSheets).forEach((sheet) => {
      try {
        const owner = sheet.ownerNode
        if (
          owner &&
          (owner.id === 'vite-plugin-vue-devtools' ||
            owner.id === 'live-inspector-styles' ||
            owner.dataset.captured !== 'true')
        )
          return

        sheet.disabled = disabled
      } catch (e) {
        // Safe skip
      }
    })
  }

  return {
    extractCssAst,
    getMatchedRules,
    getSpecificity,
    syncAstToStyles,
    isColor,
    setSheetsDisabled,
    parse,
    walk,
    generate,
    createNode(css, context) {
      try {
        // css-tree requires lowercase context names
        const normalizedContext = context.toLowerCase()
        const ast = parse(css, { context: normalizedContext })
        return ast
      } catch (e) {
        console.error('Failed to create node from CSS:', css, 'context:', context, e)
        return null
      }
    },
  }
}
